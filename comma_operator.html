<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>The Power of the Comma Operator in C++</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2, h3 {
            color: #2e3d49;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            font-size: 1.1em;
            font-family: monospace;
        }
        code {
            font-family: monospace;
            font-size: 1.1em;
        }
        ul {
            margin-left: 20px;
        }
    </style>
</head>
<body>

    <h1>The Power of the Comma Operator in C++</h1>

    <p>We all know that every ‘,’ matters in this language, so I decided to talk directly about that character today. So, how much impact can such a small little character have?</p>

    <h2>The Comma Operator</h2>
    <p>This operator comes from C, where it tells the compiler to evaluate all the expressions (left to right) and to return the result of the latest evaluated expression. For example:</p>
    
    <pre><code>
int a, b;
a = 5, b = 4, b += a, ++a, std::cout << b << " " << a; // Prints 9 6
    </code></pre>

    <p>Another example of that operator usage is as follows:</p>

    <pre><code>
for (size_t i = 0, k = 500; i < 10; ++i, ++k) { /*...*/ }
    </code></pre>

    <p>We can see this operator in action in the third section of the <code>for</code> statement. It evaluates <code>++i</code> and then evaluates <code>++k</code>.</p>

    <h3>Not Every Comma is The Comma Operator</h3>
    <p>Although it might be confusing, not every comma we see in our code uses the comma operator. For example, when we pass parameters into functions, define the arguments we want to pass to the template, or declare multiple objects using commas, these cases do not use the comma operator. Moreover, in the cases of passing arguments to functions, the evaluation order is not defined. Examples:</p>

    <pre><code>
template <typename T, typename V> void func(int, int, int);
int a = 5, b = 6, c = 7; // Not the comma operator
for (int i = 1, j = 2; i < 5; ++i); // Not the comma operator
func<int, float>(a, b, c); // Not the comma operator
    </code></pre>

    <p>At this point, some of you might think there is no reason to be afraid of such an operator, if all it does is evaluate expressions left to right. Well, we are talking about C++ here, and I think it’s time to move to the spooky sides of this operator.</p>

    <h3>Fold Expressions</h3>
    <p>Another known usage of the comma operator is as part of fold expressions (since C++17). To apply multiple unrelated expressions on the variadic parameters, we can use the comma operator as in the following example:</p>

    <pre><code>
template <typename... ArgsF>
void call_functions(ArgsF&&... argsf) {
    (argsf(), ...);
}
/*...*/
call_functions(
  [] { std::cout << "Func1\n"; },
  [] { std::cout << "Func2\n"; },
  [] { std::cout << "Func3\n"; }
);
    </code></pre>

    <h3>The ‘,’ is Out There</h3>
    <p>About a year ago someone published on Reddit the following example:</p>

    <pre><code>
for (int i = 0; i < 10,000; i += 1)
    </code></pre>

    <p>At first glance, there is nothing wrong with this code, and yet this loop will perform 0 iterations.</p>
    <p>The comma operator is attached between the following expressions: <code>i < 10</code> and <code>000</code>. Therefore, it performs the left expression and evaluates true, and then performs the right expression, evaluates false, and returns the latter.</p>

    <p>Let’s look for another example:</p>

    <pre><code>
int x = 5, y = 6, z;
z = (x, y);
    </code></pre>

    <p>In this example, the two expressions are <code>x</code> and <code>y</code>. The compiler first evaluates <code>x</code> and then <code>y</code> and returns the latter. But what would happen if we remove the parentheses?</p>

    <pre><code>
int x = 5, y = 6, z;
z = x, y;
    </code></pre>

    <p>Well, this time the expressions are <code>z = x</code> and <code>y</code>. The exact opposite of the previous example.</p>

    <h3>Dangerous Yesterday, Powerful Today</h3>
    <p>Before C++23, subscript expressions (<code>operator[]</code>) could accept only a single argument. The following example was legal until C++20:</p>

    <pre><code>
class Container {
public:
    int& operator[](int a) { /*...*/ }
};
...
Container c;
c[1, 4] = 5; // <-- 
    </code></pre>

    <p>This mistake might make someone believe it’s about accessing a specific cell in a matrix located in row 1, column 4, when it actually ignores the 1 and passes only the number 4 to the operator function.</p>

    <p>Since C++20, using the comma operator without parentheses (<code>()</code>) inside subscript expressions is deprecated, and since C++23, it’s illegal as the operator might accept more than one parameter, and the compiler will generate an error. Usage example with parentheses:</p>

    <pre><code>
Container c;
c[(1, 4)] = 5; // The intention is clear: Only one parameter is passed to the operator.
    </code></pre>

    <h3>Overloading the Comma Operator</h3>
    <p>Now that we understand the basic risk of using the comma operator, it’s time to have some fun with it and stretch the limits of this pranking operator:</p>

    <pre><code>
template <typename T>
std::ostream& operator,(std::ostream& out, T val)
{
    return out << val;
}
int main() {
    std::cout, "hello ", "world ", 42; // Prints "hello world 42"
    return 0;
}
    </code></pre>

    <p>Yes, it’s legal. But we can stretch the rules a little bit further:</p>

    <pre><code>
template <typename T, typename P>
T operator,(T lhs, P rhs)
{
    return lhs;
}
int main() {
    int x = 5, y = 6, z;
    z = (x, y);
    std::cout << z; // Prints 6
    std::string str1 = "5", str2 = "6", str3;
    str3 = (str1, str2);
    std::cout << str3; // Prints 5
    return 0;
}
    </code></pre>

    <p>This time it’s a little bit more confusing: Why does the new overload have no effect on the first case, and does have an effect on the second one?</p>

    <p>The reason is that the comma operator overload (and any other operator’s overloading) has to accept at least one parameter of class or enumeration type. Therefore, the instantiation of <code>int operator,(int, int)</code> is not legal and doesn’t apply to the first case (which uses the regular rule of the comma operator).</p>

    <p>If you also insist on forcing the first example to work by the new rule, we can make a little change:</p>

    <pre><code>
struct MyInt {
    MyInt(int a) : a(a) {}
    operator int() { return a; }
    int a;
};
...
MyInt x = 5, y = 6;
int z;
z = (x, y);
std::cout << z; // Prints 5
    </code></pre>

    <h3>Approaching Large Numbers Without This Operator</h3>
    <p>In math, we used to separate large numbers using commas. As we can’t use this approach in C++, we have to use other methods to help us with readability and maintainability issues.</p>

    <h2>Conclusion</h2>
    <p>Now that you know the comma operator is more than just a simple syntax tool, use it wisely. Avoid using it excessively or in confusing scenarios. It might look innocent, but its behavior could lead to hidden bugs or unreadable code. In general, the comma operator should only be used when the code’s behavior is explicit and obvious to the reader.</p>

    <p><i>Special thanks to Yehezkel Bernat & Ellie Bogdanov for reviewing & comments!</i></p>

</body>
</html>
